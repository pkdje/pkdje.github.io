---
title: "Ch1-2 자료구조 소개, 재귀(자기호출)와 귀납적 사고"
date: "2025-01-27"
tags: ["알고리즘"]
category: "dm"
---

자료구조 재수강을 위해 방학 기간을 활용하여 빠르게 복습하고자 한다. 이번 학기는 이전 학기와 달리 특이하게도 파이썬을 활용하여 수업한다고 하는데 기대가 크다...!
교재 역시도 쉽배자 with python이다. java는 익숙치 않아 힘들게 수강한 기억이 있는데 신기하다.

1. 자료구조의 의미
```text
책(자료)을 효율적으로 관리하는 방법
데이터에 효율적으로 접근하고 수정할 수 있도록 이를 저장, 조직, 관리하는 방법
```

2. 이 책에서 다루는 자료구조
```text
선형 자료구조: 리스트 스택, 큐
색인 자료구조: 검색트리(이진, 균형), 해시 테이블
효율적인 자료구조: 우선순위 큐: 힙
관계 처리 자료구조: 그래프
```

3. 알고리즘 표기법
```text
- 자연어(사람이 쓰는 언어)를 이용한 서술적 표현. 사람에 따라 일관성이나 명확성을 유지하기 어렵다.
- 순서도(Flow Chart)를 이용한 도식화. 복잡한 알고리즘을 표현하는 데는 한계가 있다.
- 프로그래밍 언어를 이용한 구체화. 해당 언어를 모르면 이해하기 어렵다. 다른 프로그래밍 언어로 개발할 경우 범용성이 떨어진다.
- 가상코드(Psuedo-Code)를 이용한 추상화. 위의 단점을 해결한다. 구체화하기가 쉽다.
```

4. 추상 데이터 타입: ADT
ADT(Abstract Data Type)은 세부 사항에서 벗어나 추상적으로 정의한 데이터 타입. 즉, 어떤 데이터 타입이 어떤 작업으로 이루어지는지만 표현한 것.

```text
Example: List
(a): 원소를 첫 번째, 두 번째, ..., i번째 원소로 가리킬 수 있는 자료구조
(b): i번째 자리에 새 원소 넣기, 원소 x 찾기, i번째 자리의 원소 삭제하기
이런 식으로 어떤 대상이 지원하는 '작업을 나열해 표현' 하는 것을 "추상적으로 표현한다"라고 하며, 대상을 그렇게 표현한 것을 추상 데이터 타입이라고 한다.

객체 지향 언어에서 ADT는 대략 하나의 클래스에 대응된다.
하나의 ADT 안에 여러개의 ADT가 포함될 수도 있다.
ADT는 적어도 이 작업들은 포함해야함을 의미한다. 구현할 때 추가할 수 있다.
```

5. 자료구조와 재귀
```text
재귀는 '내 안의 나를 찾는 것'이다. 
예로 n! = n*(n-1)!으로 표현될 수 있다. 즉, 크기가 n펙토리얼은 크기가 n-1인 펙토리얼을 포함하고 있다. 이처럼 어떤 문제나 함수 등이 자신과 성격이 똑같지만 크기가 더 작은 문제를 하나 이상 포함하고 있을 때 재귀적 구조를 갖고 있다고 말한다.

대부분의 프로그래밍 언어는 함수 내부에서 자신을 호출하는 자기호출 기능(recursion)을 제공한다.
```

6. 재귀 구조 예
```python
# 등차수열
seq(n):
    if (n=1):
        return 1
    else:
        return seq(n-1) + 3
```

```python
# 피보나치 수열
fib(n):
    if (n=1 or n=2):
        return 1
    else: return fib(n-1) + fib(n-2)

# 위 알고리즘은 재귀함수의 치명적인 예다. 엄청난 시간이 걸리는데 이는 한 번 계산해놓은 결과를 계속 호출하여 지수함수적인 중복을 일으키기 때문이다. 아래와 같이 계산하면 훨씬 효율적이다.

fib_fast(n):
    f[1], f[2] = 1
    for i in range(3, n+1):
        f[i] = f[i-1] + f[i-2]
        return f[n]
```

```python
# 하노이 탑
move(n, a, b, c):
    if n>0:
        move(n-1, a, c, b)
        a에 있는 원반을 b로 옮긴다
        move(n-1, c, b, a)
# move(1, x, y, z)가 총 2^n번 호출된다
```

```python
# 선택 정렬
#전체를 흝어 가장 큰 원소릴 찾는다. 이 원소를 제일 오른쪽 원소와 맞바꾼다. 다음 n-1개짜리 정렬 문제가 남는다. 이를 재귀적으로 반복한다. for 루프가 한 바퀴 돌 때마다 문제의 크기가 하나씩 작아지므로 N-1바퀴 후에는 1개짜리 문제가 남는다(A[0])이는 정렬할 필요가 없다.

selectionSort(A[], n):
    for i in range(n-1, 0, -1):
        find max A[k]
        swap A[k], A[i]

selectionSort(A[], n):
    if n>1:
        find max A[k]
        swap A[k], A[n-1]
        selectionSort(A, n-1)
```

6-4 중위, 전위, 후위 표현볍
- 중위 표현법(Infix Expression): A + B와 같이 연산자가 피연산자 사이에 놓이는 수식 모양
- 전위 표현볍(Prefix Expression) + A B처럼 연산자를 앞에 둔 모양
- 후위 표현법(Postfix Expression) A B +처럼 연산자를 뒤에 둔 모양

A + B * C - D = - + A * B C D = A B C * + D -

6-5 깊이 우선 탐색(DFS, Depth-First Search)
모든 노드를 방문하는 방법을 찾는 그래프 알고리즘에서 유명한 기초 문제.

```python
#노드 x에서 이를 수 있는 모든 노드 및 경로 찾기. 모든 노드 v에 대해 v.visited는 fals로 초기화
DFS(x):
    x.visited = true
    x에서 화살표로 연결된 모든 노드 y 각각에 대하여
        if (y.visited = false): DFS(y)
```

7. 재귀와 수학적 귀납법
모든 재귀 알고리즘은 명시적 또는 암묵적으로 다음 세 가지 구성 요소를 반드시 갖추어야 한다.
```text
-경계 조건(Base Condition) 또는 종료 조건: 재귀 호출이 반복되다 궁극적으로 끝나는 조건
-재귀 호출
-관계: 닮음꼴 작은 문제(들)와 본 문제 간의 관계를 나타내는 부분
````

경계 조건은 수학적 귀납법의 베이스 케이스와 대응되고, 재귀 호출은 귀납적 가정과 대응되고, 관계는 자신보다 작은 문제에 대해 귀납적 가정을 하고 나면 자신이 맞다는 것을 보이는 과정과 대응된다.



